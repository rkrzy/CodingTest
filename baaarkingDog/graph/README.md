# 그래프관련 내용 정리

- 그래프 : 정점과 간선으로 이루어진 자료구조

- 나가는것 : outdegree, 들어오는거 : indgree
- 순환 사이클 : 사이클이 하나라도 존재
- 비순환 그래프 : 사이클이 하나도 없는것
- 완전 그래프 : 모든 서로 다른 정점이 연결되어 있는것
- 연결 그래프 : 
- 단순 그래프 : 두 정점 사이의 간선이 1개 이하이고 루프가 존재하지 않는 그래프

### 표현법

1. 인접행렬 
   1. 어떤 정점이 연결되어 있는지 O(1)에 아는게 가능하다.
2. 인접리스트
   1. V개의 리스트를 만들어서 인접하는 요소만 추가해주면 된다.
   2. O(V + E)

### 비교
- 공간복잡도
  - 인접 행렬 : O(V^2)
  - 인접 리스트 : O(V + E)
- 정점 u,v 가 연결되어 있는지 확인하는 시간 복잡도
  - 인접 행렬 : O(1)
  - 인접 리스트 : O(min(deg(u), deg(v)))
- 정점 v와 연결된 모든 정점을 확인하는 시간 복잡도
  - 인접 행렬 : O(V)
  - 인접 리스트 : O(deg(v))
- 효율적인 상황
  - 인접 행렬 : 두 점의 연결여부를 자주 확인할 때
  - 인접 리스트 : 특정 정점에 연결된 모든 정점을 자주 확인할 때 E가 V^2보다 훨씬 작을 때

### BFS
- 그래프에서 너비를 우선으로 방문하는 알고리즘
- 방법
  - 시작하는 정점을 큐에 넣고 방문했다는 표시를 남김
  - 큐에서 정점을 꺼내어 그 정점과 연결된 모든 정점들에 대해 3번을 진행
  - 해당 정점을 이전에 방문했다면 아무 것도 하지 않고, 처음으로 방문했다면 방문했다는 표시를 남기고 해당 칸을 큐에 삽입
  - 큐가 빌때까지 2번을 반복
- 모든 정점이 큐에 최대 1번씩 들어가므로 인접 리스트 O(V + E), 인접 행렬에서 O(V^2)의 시간복잡도.

### DFS
- 시작하는 정점을 스택에 넣고 방문했다는 표시를 남김
- 스택에서 정점을 꺼내어 그 정점과 연결된 모든 정점들에 대해 3번을 진행
- 해당 정점을 이전에 방문했다면 아무것도 하지 않고 처음으로 방문했다면 방문했다는 표시를 남기고 해당 칸을 스택에 삽입
- 스택이 빌 때까지 2번을 반복
- BFS와 같이 모든 정점이 스택에 최대 1번씩 들어가므로 인접 리스트에서 O(V+E), 인접 행렬에서 O(V^2)의 시간복잡도

implement.cpp : 간단한 구현

### 연습 문제 풀이
- Practice1.cpp : 백준 11724 <a href = "https://www.acmicpc.net/problem/11724"> 연결 요소의 개수</a>
- Practice2.cpp : 백준 1260 <a href = "https://www.acmicpc.net/problem/1260">DFS와 BFS</a>

### 응용 문제 풀이
- Problem1.cpp : 백준 5567 <a href = "https://www.acmicpc.net/problem/5567">결혼식</a>
- Problem2.cpp : 백준 11430 <a href = "https://www.acmicpc.net/problem/11403">경로 찾기</a>
- Problem3.cpp : 백준 2660 <a href = "https://www.acmicpc.net/problem/2660">회장뽑기</a> ->  <span style="color:red;">혼자서 해결을 못했다.<span>
- Problem4.cpp : 백준 1389 <a href = "https://www.acmicpc.net/problem/1389">케빈 베이컨의 6단계 법칙</a>
- Problem5.cpp : 백준 1325 <a href = "https://www.acmicpc.net/problem/1325">효율적인 해킹</a>